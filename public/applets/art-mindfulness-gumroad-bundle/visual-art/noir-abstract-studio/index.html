<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Noir Abstract Studio</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&family=Roboto+Mono:wght@400;500&display=swap');

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Roboto Mono', monospace;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            cursor: crosshair;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            z-index: 10;
            pointer-events: none; /* Let clicks pass through to canvas where not on buttons */
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .header {
            text-align: center;
            color: #eee;
            text-shadow: 0 2px 10px rgba(0,0,0,0.8);
            pointer-events: auto;
        }

        .header h1 {
            font-family: 'Playfair Display', serif;
            font-size: 2.5rem;
            margin: 0;
            letter-spacing: 2px;
            background: linear-gradient(to right, #fff, #aaa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header p {
            font-size: 0.8rem;
            opacity: 0.7;
            margin-top: 5px;
        }

        .toolbar {
            display: flex;
            gap: 10px;
            justify-content: center;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 50px;
            border: 1px solid rgba(255,255,255,0.1);
            pointer-events: auto;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            flex-wrap: wrap;
        }

        .tool-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            background: #333;
            color: white;
            position: relative;
        }

        .tool-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .tool-btn.active {
            border-color: #fff;
            box-shadow: 0 0 15px rgba(255,255,255,0.3);
            transform: scale(1.1);
        }

        /* Tool specific styles */
        .btn-city { background: linear-gradient(135deg, #222, #444); }
        .btn-red { background: linear-gradient(135deg, #800, #f00); }
        .btn-yellow { background: linear-gradient(135deg, #b8860b, #ffd700); color: #000; }
        .btn-white { background: #eee; color: #000; }
        .btn-fog { background: linear-gradient(135deg, #555, #999); opacity: 0.8; }
        
        .action-btn {
            padding: 0 20px;
            border-radius: 25px;
            width: auto;
            font-size: 0.8rem;
            text-transform: uppercase;
            font-weight: bold;
            background: transparent;
            border: 1px solid rgba(255,255,255,0.3);
        }
        
        .action-btn:hover {
            background: rgba(255,255,255,0.1);
        }

        /* Tutorial Overlay */
        #tutorial {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.85);
            padding: 30px;
            border-radius: 10px;
            color: white;
            text-align: center;
            max-width: 400px;
            z-index: 20;
            border: 1px solid #444;
            pointer-events: auto;
            transition: opacity 0.5s;
        }
        
        #tutorial h2 { margin-top: 0; font-family: 'Playfair Display', serif; }
        #tutorial button {
            margin-top: 20px;
            padding: 10px 20px;
            background: #e03e3e;
            border: none;
            color: white;
            font-family: 'Roboto Mono', monospace;
            cursor: pointer;
            border-radius: 5px;
        }

    </style>
</head>
<body>

    <div id="tutorial">
        <h2>Abstract Noir Studio</h2>
        <p>Recreate the mood of the city.</p>
        <ul style="text-align: left; font-size: 0.9rem; line-height: 1.6;">
            <li>üè¢ <strong>Structure</strong>: Drag to build the dark skyline.</li>
            <li>ü©∏ <strong>Passion</strong>: Splash vibrant red accents.</li>
            <li>üí° <strong>Lights</strong>: Click to add windows and street lamps.</li>
            <li>üå´Ô∏è <strong>Fog</strong>: Add atmospheric depth.</li>
        </ul>
        <button onclick="closeTutorial()">Start Painting</button>
    </div>

    <div id="ui-layer">
        <div class="header">
            <h1>NOIR SCAPE</h1>
            <p>Interactive Abstract Generator</p>
        </div>

        <div class="toolbar">
            <button class="tool-btn btn-city active" onclick="setTool('city')" title="City Structures">üè¢</button>
            <button class="tool-btn btn-red" onclick="setTool('red')" title="Red Accents">ü©∏</button>
            <button class="tool-btn btn-yellow" onclick="setTool('light')" title="City Lights">üí°</button>
            <button class="tool-btn btn-white" onclick="setTool('white')" title="White Noise">‚ùÑÔ∏è</button>
            <button class="tool-btn btn-fog" onclick="setTool('fog')" title="Atmospheric Fog">üå´Ô∏è</button>
            <div style="width: 1px; background: rgba(255,255,255,0.2); margin: 0 10px;"></div>
            <button class="tool-btn action-btn" onclick="generateRandom()">Auto</button>
            <button class="tool-btn action-btn" onclick="clearCanvas()">Clear</button>
            <button class="tool-btn action-btn" onclick="saveArt()">Save</button>
        </div>
    </div>

    <div id="canvas-container">
        <canvas id="artCanvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('artCanvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        let currentTool = 'city';
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let drips = [];

        // Setup Canvas
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            // Initial background
            drawBackground();
        }
        window.addEventListener('resize', resize);

        function drawBackground() {
            // Create a moody gradient background
            const grad = ctx.createLinearGradient(0, 0, 0, height);
            grad.addColorStop(0, '#2b2d33'); // Lighter grey top (fog)
            grad.addColorStop(0.4, '#1a1a1a'); // Dark middle
            grad.addColorStop(1, '#000000'); // Black bottom
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, width, height);
        }

        // Tool Selection
        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            // Find button with matching onclick and add active
            const buttons = document.querySelectorAll('.tool-btn');
            buttons.forEach(btn => {
                if(btn.getAttribute('onclick').includes(`'${tool}'`)) {
                    btn.classList.add('active');
                }
            });
        }

        function closeTutorial() {
            document.getElementById('tutorial').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('tutorial').style.display = 'none';
                generateRandom(); // Start with something on screen
            }, 500);
        }

        // Drawing Logic
        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            lastX = e.clientX;
            lastY = e.clientY;
            draw(e);
        });
        canvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;
            draw(e);
            lastX = e.clientX;
            lastY = e.clientY;
        });
        canvas.addEventListener('mouseup', () => isDrawing = false);
        canvas.addEventListener('mouseout', () => isDrawing = false);

        // Touch support
        canvas.addEventListener('touchstart', (e) => {
            isDrawing = true;
            lastX = e.touches[0].clientX;
            lastY = e.touches[0].clientY;
            draw(e.touches[0]);
            e.preventDefault();
        });
        canvas.addEventListener('touchmove', (e) => {
            if (!isDrawing) return;
            draw(e.touches[0]);
            lastX = e.touches[0].clientX;
            lastY = e.touches[0].clientY;
            e.preventDefault();
        });

        function draw(e) {
            const x = e.clientX;
            const y = e.clientY;
            const speed = Math.sqrt(Math.pow(x - lastX, 2) + Math.pow(y - lastY, 2));

            ctx.save();

            if (currentTool === 'city') {
                // Draw vertical blocks resembling buildings
                ctx.fillStyle = `rgba(${Math.random()*30}, ${Math.random()*30}, ${Math.random()*40}, 0.9)`;
                const w = Math.random() * 60 + 20;
                const h = (height - y) + (Math.random() * 100); // Extend to bottom
                // Snap to bottom somewhat
                const drawY = y; 
                ctx.fillRect(x - w/2, drawY, w, height - drawY);
                
                // Add some texture lines
                ctx.strokeStyle = 'rgba(0,0,0,0.5)';
                ctx.beginPath();
                ctx.moveTo(x, drawY);
                ctx.lineTo(x, height);
                ctx.stroke();

            } else if (currentTool === 'red') {
                // Vibrant red strokes with drips
                ctx.strokeStyle = '#D93025';
                ctx.lineWidth = Math.random() * 20 + 5;
                ctx.lineCap = 'round';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#800';
                
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(x, y);
                ctx.stroke();

                // Chance to spawn a drip
                if (Math.random() > 0.8) {
                    drips.push({
                        x: x,
                        y: y,
                        vy: Math.random() * 2 + 1,
                        color: '#D93025',
                        life: 100 + Math.random() * 100,
                        width: Math.random() * 4 + 1
                    });
                }

            } else if (currentTool === 'light') {
                // Yellow/Orange square lights
                const size = Math.random() * 10 + 4;
                ctx.fillStyle = Math.random() > 0.5 ? '#F9AB00' : '#FFF';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#F9AB00';
                ctx.globalCompositeOperation = 'lighter';
                
                // Draw scattered windows
                if (Math.random() > 0.5) {
                    ctx.fillRect(x + (Math.random()*40-20), y + (Math.random()*40-20), size, size * 1.5);
                }
                
                // Occasional "streak" reflection
                if (Math.random() > 0.9) {
                    ctx.fillStyle = 'rgba(249, 171, 0, 0.3)';
                    ctx.fillRect(x - 20, y + 20, 40, 2);
                }

            } else if (currentTool === 'white') {
                // Chaotic white noise/scratching
                ctx.strokeStyle = '#F1F3F5';
                ctx.lineWidth = Math.random() * 2 + 1;
                ctx.beginPath();
                ctx.moveTo(lastX + (Math.random()*20-10), lastY + (Math.random()*20-10));
                ctx.lineTo(x + (Math.random()*20-10), y + (Math.random()*20-10));
                ctx.stroke();
                
                // Splatter
                if (Math.random() > 0.9) {
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(x + (Math.random()*40-20), y + (Math.random()*40-20), Math.random()*2, 0, Math.PI*2);
                    ctx.fill();
                }

            } else if (currentTool === 'fog') {
                // Soft grey airbrush
                const rad = 50;
                const grad = ctx.createRadialGradient(x, y, 0, x, y, rad);
                grad.addColorStop(0, 'rgba(100, 100, 100, 0.1)');
                grad.addColorStop(1, 'rgba(100, 100, 100, 0)');
                ctx.fillStyle = grad;
                ctx.fillRect(x - rad, y - rad, rad * 2, rad * 2);
            }

            ctx.restore();
        }

        // Animation Loop for Drips
        function animate() {
            if (drips.length > 0) {
                drips.forEach((drip, index) => {
                    ctx.fillStyle = drip.color;
                    ctx.globalAlpha = drip.life / 200;
                    ctx.fillRect(drip.x, drip.y, drip.width, drip.vy);
                    
                    drip.y += drip.vy;
                    drip.life--;

                    if (drip.life <= 0) {
                        drips.splice(index, 1);
                    }
                });
                ctx.globalAlpha = 1.0;
            }
            requestAnimationFrame(animate);
        }

        // Helper Functions
        function clearCanvas() {
            drips = [];
            drawBackground();
        }

        function saveArt() {
            const link = document.createElement('a');
            link.download = 'noir-abstract.png';
            link.href = canvas.toDataURL();
            link.click();
        }

        function generateRandom() {
            clearCanvas();
            
            // 1. Generate Skyline
            const buildingCount = 15;
            for(let i=0; i<buildingCount; i++) {
                const x = Math.random() * width;
                const w = Math.random() * 100 + 40;
                const h = Math.random() * (height * 0.6) + (height * 0.2);
                const y = height - h;
                
                ctx.fillStyle = `rgb(${Math.random()*20}, ${Math.random()*20}, ${Math.random()*25})`;
                ctx.fillRect(x, y, w, h);
                
                // Add windows
                if(Math.random() > 0.3) {
                    const floors = Math.floor(h / 20);
                    const cols = Math.floor(w / 15);
                    ctx.fillStyle = '#F9AB00';
                    ctx.shadowBlur = 5;
                    ctx.shadowColor = '#F9AB00';
                    
                    for(let f=0; f<floors; f++) {
                        for(let c=0; c<cols; c++) {
                            if(Math.random() > 0.8) { // Only some lights on
                                ctx.fillRect(x + 5 + c*15, y + 5 + f*20, 6, 10);
                            }
                        }
                    }
                    ctx.shadowBlur = 0;
                }
            }

            // 2. Add Red Splashes
            for(let i=0; i<5; i++) {
                let startX = Math.random() * width;
                let startY = height/2 + Math.random() * height/2;
                ctx.strokeStyle = '#D93025';
                ctx.lineWidth = Math.random() * 30 + 10;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.bezierCurveTo(
                    startX + Math.random()*200-100, startY - Math.random()*100,
                    startX + Math.random()*200-100, startY + Math.random()*100,
                    startX + Math.random()*300-150, startY + Math.random()*100
                );
                ctx.stroke();
                
                // Add drips
                for(let d=0; d<10; d++) {
                    drips.push({
                        x: startX + Math.random()*100 - 50,
                        y: startY,
                        vy: Math.random() * 3 + 1,
                        color: '#D93025',
                        life: 200,
                        width: Math.random() * 4 + 1
                    });
                }
            }

            // 3. White Noise
            for(let i=0; i<20; i++) {
                ctx.fillStyle = '#fff';
                ctx.globalAlpha = 0.8;
                let x = Math.random() * width;
                let y = Math.random() * height;
                let w = Math.random() * 40;
                let h = Math.random() * 5;
                ctx.fillRect(x, y, w, h);
            }
            ctx.globalAlpha = 1;
        }

        // Init
        resize();
        animate();

    </script>
</body>
</html>