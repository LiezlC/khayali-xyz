<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Midnight Magic Citadel</title>
    <style>
        :root {
            --bg-top: #1a0525;
            --bg-btm: #000000;
            --castle-color: #0d0214;
            --window-color: #ffdb4d;
            --accent-green: #00ff9d;
            --accent-gold: #ffd700;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: linear-gradient(to bottom, var(--bg-top), #2a1038 60%, var(--bg-btm));
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }

        #game-ui {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 10;
            color: white;
            text-shadow: 0 0 10px var(--accent-green);
        }

        h1 {
            margin: 0;
            font-weight: 300;
            letter-spacing: 4px;
            text-transform: uppercase;
            font-size: 1.5rem;
        }

        p {
            font-size: 0.9rem;
            opacity: 0.8;
            margin-top: 5px;
        }

        #energy-bar-container {
            width: 300px;
            height: 6px;
            background: rgba(255,255,255,0.1);
            margin: 10px auto;
            border-radius: 3px;
            overflow: hidden;
        }

        #energy-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, var(--accent-green), var(--accent-gold));
            transition: width 0.1s;
            box-shadow: 0 0 10px var(--accent-gold);
        }

        /* The Canvas for Particles */
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 5; /* Behind UI, In front of castle? No, let's mix. */
            pointer-events: auto; /* Clicks go here */
        }

        /* The Castle Silhouette */
        #castle-container {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 40%;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            z-index: 2;
            pointer-events: none;
            filter: drop-shadow(0 0 20px rgba(0,0,0,0.8));
        }

        .tower {
            background: var(--castle-color);
            position: relative;
            margin: 0 -5px; /* Overlap slightly */
            transition: transform 0.1s;
        }

        .tower::before {
            content: '';
            position: absolute;
            top: -100%; /* Adjust based on width in JS */
            left: 0;
            width: 0;
            height: 0;
            border-style: solid;
            /* Border widths set in JS */
            border-color: transparent transparent var(--castle-color) transparent;
        }

        .window {
            background: var(--window-color);
            position: absolute;
            border-radius: 2px;
            box-shadow: 0 0 5px var(--window-color);
            opacity: 0;
            transition: opacity 0.5s;
        }

        .window.lit {
            opacity: 0.8;
        }

        /* Foreground Hill */
        .hill {
            position: absolute;
            bottom: -50px;
            left: 0;
            width: 100%;
            height: 150px;
            background: #050108;
            border-radius: 50% 50% 0 0;
            transform: scaleX(1.5);
            z-index: 3;
        }

        /* Interaction Hint */
        .hint {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255,255,255,0.4);
            font-size: 0.8rem;
            z-index: 10;
            pointer-events: none;
        }

    </style>
</head>
<body>

    <div id="game-ui">
        <h1>Arcane Citadel</h1>
        <p>Click or Drag to Cast Spells</p>
        <div id="energy-bar-container">
            <div id="energy-bar"></div>
        </div>
    </div>

    <canvas id="magicCanvas"></canvas>

    <div id="castle-container">
        <!-- Towers generated by JS -->
    </div>
    <div class="hill"></div>
    <div class="hint">Tap anywhere to unleash magic â€¢ Build energy for the Mega Burst</div>

    <script>
        /**
         * SETUP
         */
        const canvas = document.getElementById('magicCanvas');
        const ctx = canvas.getContext('2d');
        const castleContainer = document.getElementById('castle-container');
        const energyBar = document.getElementById('energy-bar');
        
        let width, height;
        let particles = [];
        let energy = 0;
        const MAX_ENERGY = 100;
        let hueRotation = 0;

        // Resize handling
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        window.addEventListener('resize', resize);
        resize();

        /**
         * CASTLE GENERATION
         * Procedurally generates a silhouette similar to the input image.
         */
        function buildCastle() {
            const towerCount = Math.floor(width / 40); 
            for (let i = 0; i < towerCount; i++) {
                const h = 50 + Math.random() * 150; // Height
                const w = 20 + Math.random() * 40;  // Width
                
                const tower = document.createElement('div');
                tower.className = 'tower';
                tower.style.width = `${w}px`;
                tower.style.height = `${h}px`;
                
                // Randomize z-index for depth
                tower.style.zIndex = Math.floor(Math.random() * 5);
                
                // Roof logic
                const roofHeight = 20 + Math.random() * 40;
                const style = document.createElement('style');
                // We use inline styles for the pseudo element logic via CSS variables would be cleaner, 
                // but direct manipulation is fine here.
                tower.style.borderTop = "none"; 
                
                // Create roof manually to avoid complex pseudo-element JS manipulation
                const roof = document.createElement('div');
                roof.style.position = 'absolute';
                roof.style.bottom = '100%';
                roof.style.left = '0';
                roof.style.width = '0';
                roof.style.height = '0';
                roof.style.borderLeft = `${w/2}px solid transparent`;
                roof.style.borderRight = `${w/2}px solid transparent`;
                roof.style.borderBottom = `${roofHeight}px solid var(--castle-color)`;
                tower.appendChild(roof);

                // Windows
                const numWindows = Math.floor(Math.random() * 4);
                for(let j=0; j<numWindows; j++) {
                    const win = document.createElement('div');
                    win.className = 'window';
                    win.style.width = '4px';
                    win.style.height = '6px';
                    win.style.left = `${Math.random() * (w - 10) + 3}px`;
                    win.style.top = `${Math.random() * (h - 20) + 10}px`;
                    // Randomly light up
                    if(Math.random() > 0.3) win.classList.add('lit');
                    tower.appendChild(win);
                }

                castleContainer.appendChild(tower);
            }
            
            // Create one BIG central spire (The source of magic)
            const mainSpire = document.createElement('div');
            mainSpire.className = 'tower';
            mainSpire.style.width = '60px';
            mainSpire.style.height = '250px';
            mainSpire.style.position = 'absolute';
            mainSpire.style.bottom = '0';
            mainSpire.style.left = '50%';
            mainSpire.style.transform = 'translateX(-50%)';
            mainSpire.style.zIndex = '6';
            
            const mainRoof = document.createElement('div');
            mainRoof.style.position = 'absolute';
            mainRoof.style.bottom = '100%';
            mainRoof.style.left = '0';
            mainRoof.style.borderLeft = `30px solid transparent`;
            mainRoof.style.borderRight = `30px solid transparent`;
            mainRoof.style.borderBottom = `80px solid var(--castle-color)`;
            mainSpire.appendChild(mainRoof);
            
            castleContainer.appendChild(mainSpire);
        }
        buildCastle();

        /**
         * PARTICLE SYSTEM
         */
        class Particle {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type; // 'spark', 'trail', 'orb'
                this.life = 1.0;
                this.decay = 0.01 + Math.random() * 0.02;
                
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 2;
                
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                
                // Physics tweaks based on type
                if (type === 'trail') {
                    this.vx *= 1.5;
                    this.vy *= 1.5;
                    this.decay = 0.015;
                    this.history = [];
                } else if (type === 'orb') {
                    this.vx *= 0.5;
                    this.vy *= 0.5;
                    this.decay = 0.005;
                }

                // Colors from image
                const colors = ['#50fa7b', '#f1fa8c', '#ff79c6', '#8be9fd'];
                this.color = colors[Math.floor(Math.random() * colors.length)];
                
                if (type === 'trail') {
                    // Green/Gold dominant for trails like the image
                    this.color = Math.random() > 0.5 ? '#00ff9d' : '#ffd700';
                }
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;

                // Gravity
                this.vy += 0.1;
                // Drag
                this.vx *= 0.96;
                this.vy *= 0.96;

                if (this.type === 'trail') {
                    this.history.push({x: this.x, y: this.y});
                    if (this.history.length > 10) this.history.shift();
                }
            }

            draw(ctx) {
                ctx.globalAlpha = this.life;
                
                if (this.type === 'trail') {
                    ctx.beginPath();
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 2;
                    if (this.history.length > 0) {
                        ctx.moveTo(this.history[0].x, this.history[0].y);
                        for (let i = 1; i < this.history.length; i++) {
                            ctx.lineTo(this.history[i].x, this.history[i].y);
                        }
                    }
                    ctx.lineTo(this.x, this.y);
                    ctx.stroke();
                } else {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.type === 'orb' ? 4 : 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
            }
        }

        function spawnExplosion(x, y, scale = 1) {
            const count = 30 * scale;
            for (let i = 0; i < count; i++) {
                const type = Math.random() > 0.7 ? 'trail' : 'spark';
                particles.push(new Particle(x, y, type));
            }
            
            // Flash effect
            const flash = document.createElement('div');
            flash.style.position = 'absolute';
            flash.style.left = (x - 50) + 'px';
            flash.style.top = (y - 50) + 'px';
            flash.style.width = '100px';
            flash.style.height = '100px';
            flash.style.borderRadius = '50%';
            flash.style.background = 'radial-gradient(circle, white, transparent)';
            flash.style.pointerEvents = 'none';
            flash.style.zIndex = '4';
            flash.style.opacity = '0.8';
            flash.style.transition = 'opacity 0.2s, transform 0.2s';
            document.body.appendChild(flash);
            
            requestAnimationFrame(() => {
                flash.style.opacity = '0';
                flash.style.transform = 'scale(3)';
            });
            setTimeout(() => flash.remove(), 300);

            // Shake castle
            if (scale > 1.5) {
                castleContainer.style.transform = `translate(${Math.random()*10-5}px, ${Math.random()*10-5}px)`;
                setTimeout(() => castleContainer.style.transform = 'translate(0,0)', 100);
            }
        }

        function megaBurst() {
            // The central explosion from the image
            const cx = width / 2;
            const cy = height - (height * 0.4) - 50; // Top of central spire
            
            spawnExplosion(cx, cy, 5);
            
            // Delayed secondary bursts
            setTimeout(() => spawnExplosion(cx, cy, 3), 100);
            setTimeout(() => spawnExplosion(cx, cy, 3), 200);
            
            // Add specific "Long Trails" to mimic the image's wild arcs
            for(let i=0; i<20; i++) {
                const p = new Particle(cx, cy, 'trail');
                p.vx = (Math.random() - 0.5) * 25; // High horizontal velocity
                p.vy = (Math.random() - 1) * 25;   // High upward velocity
                p.decay = 0.008; // Long life
                particles.push(p);
            }
        }

        /**
         * LOOP
         */
        function animate() {
            ctx.clearRect(0, 0, width, height);
            
            // Composite operation for "glowing" effect
            ctx.globalCompositeOperation = 'lighter';

            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.update();
                p.draw(ctx);
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
            
            ctx.globalCompositeOperation = 'source-over';
            requestAnimationFrame(animate);
        }
        animate();

        /**
         * INPUT HANDLING
         */
        let isDragging = false;

        function handleInput(x, y) {
            spawnExplosion(x, y, 1);
            
            // Increase Energy
            energy += 5;
            if (energy >= MAX_ENERGY) {
                energy = 0;
                megaBurst();
                // Trigger UI flash
                energyBar.style.background = 'white';
                setTimeout(() => {
                    energyBar.style.background = 'linear-gradient(90deg, var(--accent-green), var(--accent-gold))';
                }, 100);
            }
            energyBar.style.width = `${(energy / MAX_ENERGY) * 100}%`;
        }

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            handleInput(e.clientX, e.clientY);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                // Limit spawn rate
                if (Math.random() > 0.8) handleInput(e.clientX, e.clientY);
            }
        });

        window.addEventListener('mouseup', () => isDragging = false);

        // Touch support
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            for (let i = 0; i < e.touches.length; i++) {
                handleInput(e.touches[i].clientX, e.touches[i].clientY);
            }
        }, {passive: false});

        // Auto-trigger initially to match the image vibe
        setTimeout(megaBurst, 500);

    </script>
</body>
</html>