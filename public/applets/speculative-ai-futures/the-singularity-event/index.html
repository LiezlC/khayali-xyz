<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Singularity Event</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;600&family=Space+Mono:wght@400;700&display=swap');

        :root {
            --bg-dark: #0f172a;
            --glow-primary: #38bdf8;
            --glow-secondary: #f472b6;
            --silhouette: #020617;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-dark);
            font-family: 'Inter', sans-serif;
            user-select: none;
        }

        /* The Sky Background Layer */
        #sky-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 50% 30%, 
                rgba(255, 255, 255, 1) 0%, 
                rgba(255, 240, 200, 0.8) 15%, 
                rgba(244, 114, 182, 0.6) 30%, 
                rgba(56, 189, 248, 0.3) 50%, 
                rgba(15, 23, 42, 1) 90%);
            z-index: 0;
            transition: background 0.5s ease;
        }

        /* Fog Animation */
        .fog {
            position: absolute;
            width: 200%;
            height: 100%;
            background: linear-gradient(to right, transparent 0%, rgba(255,255,255,0.1) 50%, transparent 100%);
            animation: drift 20s linear infinite;
            pointer-events: none;
            z-index: 1;
        }

        @keyframes drift {
            from { transform: translateX(-50%); }
            to { transform: translateX(0%); }
        }

        /* Canvas for Crowd and Effects */
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 2;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: flex;
            gap: 1rem;
            align-items: center;
            width: 90%;
            max-width: 800px;
            pointer-events: none; /* Let clicks pass through to canvas */
        }

        .hud-panel {
            background: rgba(15, 23, 42, 0.6);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1rem 1.5rem;
            border-radius: 16px;
            color: white;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            pointer-events: auto;
            transition: all 0.3s ease;
        }

        .hud-panel:hover {
            background: rgba(15, 23, 42, 0.8);
            border-color: rgba(255, 255, 255, 0.3);
        }

        h1 {
            font-family: 'Space Mono', monospace;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: rgba(255,255,255,0.6);
            margin-bottom: 0.5rem;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            background: linear-gradient(to right, #fff, #cbd5e1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .controls {
            display: flex;
            gap: 0.5rem;
        }

        button {
            background: rgba(255,255,255,0.1);
            border: none;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Space Mono', monospace;
            font-size: 0.75rem;
            transition: all 0.2s;
            border: 1px solid transparent;
        }

        button:hover {
            background: rgba(255,255,255,0.2);
            border-color: rgba(255,255,255,0.4);
        }

        button.active {
            background: var(--glow-primary);
            color: #000;
            font-weight: bold;
            box-shadow: 0 0 15px var(--glow-primary);
        }

        /* Floating Spires (CSS Shapes) */
        .spire {
            position: absolute;
            bottom: 0;
            background: #020617;
            width: 40px;
            height: 30vh;
            z-index: 1;
            clip-path: polygon(20% 0%, 80% 0%, 100% 100%, 0% 100%);
            opacity: 0.8;
        }
        .spire::after {
            content: '';
            position: absolute;
            top: -40px;
            left: 10px;
            width: 20px;
            height: 60px;
            background: #020617;
            clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
        }

        /* Tutorial Tooltip */
        #tutorial {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            z-index: 20;
            pointer-events: none;
            opacity: 1;
            transition: opacity 1s ease;
        }
        .key {
            display: inline-block;
            padding: 2px 8px;
            border: 1px solid rgba(255,255,255,0.4);
            border-radius: 4px;
            font-family: 'Space Mono', monospace;
            font-size: 0.8rem;
            margin: 0 4px;
        }

    </style>
</head>
<body>

    <!-- Background Elements -->
    <div id="sky-layer"></div>
    <div class="fog" style="top: 20%; opacity: 0.3;"></div>
    <div class="fog" style="top: 40%; opacity: 0.5; animation-duration: 25s;"></div>
    
    <!-- Silhouette Structures (Left side of image) -->
    <div class="spire" style="left: 5%; height: 25vh;"></div>
    <div class="spire" style="left: 8%; height: 35vh; width: 60px;"></div>
    <div class="spire" style="left: 15%; height: 15vh;"></div>

    <!-- Main Canvas -->
    <canvas id="world"></canvas>

    <!-- Tutorial -->
    <div id="tutorial">
        <h2 class="text-2xl font-light mb-2 tracking-widest">THE ARRIVAL</h2>
        <p class="text-sm text-gray-300">Move mouse to guide the Singularity.</p>
        <p class="text-sm text-gray-300 mt-1">Hold <span class="key">LMB</span> to Abduct. Click <span class="key">Space</span> to Pulse.</p>
    </div>

    <!-- UI HUD -->
    <div id="ui-layer">
        <div class="hud-panel flex-1">
            <h1>Ascended</h1>
            <div class="stat-value" id="score">0</div>
        </div>
        <div class="hud-panel flex-1">
            <h1>Population</h1>
            <div class="stat-value" id="population">0</div>
        </div>
        <div class="hud-panel">
            <h1>Frequency</h1>
            <div class="controls">
                <button id="mode-calm" onclick="setMode('calm')">Observed</button>
                <button id="mode-chaos" onclick="setMode('chaos')">Panic</button>
                <button id="mode-rapture" class="active" onclick="setMode('rapture')">Rapture</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('world');
        const ctx = canvas.getContext('2d');
        
        // State
        let width, height;
        let mouse = { x: 0, y: 0, down: false };
        let entities = [];
        let particles = [];
        let drones = [];
        let score = 0;
        let mode = 'rapture'; // calm, chaos, rapture
        let frame = 0;
        let pulseRadius = 0;

        // Config
        const CROWD_SIZE = 150;
        const GROUND_LEVEL_RATIO = 0.85;

        // Resize
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        window.addEventListener('resize', resize);
        resize();

        // Input Handling
        window.addEventListener('mousemove', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
            
            // Hide tutorial on movement
            if(frame > 100) {
                document.getElementById('tutorial').style.opacity = 0;
            }
        });
        window.addEventListener('mousedown', () => mouse.down = true);
        window.addEventListener('mouseup', () => mouse.down = false);
        window.addEventListener('keydown', (e) => {
            if(e.code === 'Space') {
                pulseRadius = 10;
            }
        });

        // Classes
        class Drone {
            constructor() {
                this.x = Math.random() * width;
                this.y = Math.random() * (height * 0.4);
                this.speed = (Math.random() * 0.5) + 0.2;
                this.size = Math.random() * 10 + 5;
            }

            update() {
                this.x += this.speed;
                if (this.x > width + 50) this.x = -50;
            }

            draw() {
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x - this.size, this.y - this.size/3);
                ctx.lineTo(this.x - this.size, this.y + this.size/3);
                ctx.fill();
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = -(Math.random() * 2 + 1);
                this.life = 1.0;
                this.color = color || '#fff';
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 0.01;
            }

            draw() {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 1.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        class Person {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = Math.random() * width;
                // Create depth by varying Y slightly around the "ground line"
                const groundBase = height * GROUND_LEVEL_RATIO;
                this.y = groundBase + (Math.random() * 100 - 20); 
                
                // Scale based on Y (perspective)
                this.scale = 0.5 + (this.y - groundBase + 50) / 150;
                
                this.state = 'idle'; // idle, walking, ascending
                this.ascendSpeed = 0;
                this.opacity = 1;
                this.walkOffset = Math.random() * 100;
                this.targetX = this.x;
            }

            update() {
                if (this.state === 'ascending') {
                    this.y -= this.ascendSpeed;
                    this.ascendSpeed += 0.05;
                    this.x += (Math.random() - 0.5) * 2; // Jitter
                    this.opacity -= 0.01;
                    
                    // Emit particles
                    if (Math.random() > 0.8) {
                        particles.push(new Particle(this.x, this.y - 40 * this.scale, '#38bdf8'));
                    }

                    if (this.opacity <= 0) {
                        score++;
                        this.reset();
                        updateUI();
                    }
                    return;
                }

                // Logic based on mode and mouse
                const dx = mouse.x - this.x;
                const dy = mouse.y - (this.y - 50); // Head height
                const dist = Math.sqrt(dx*dx + dy*dy);

                // Pulse Effect
                if (pulseRadius > 0 && dist < pulseRadius + 200) {
                    // Push away
                    this.x += (this.x - mouse.x) * 0.1;
                }

                // Attraction / Behavior
                if (mode === 'rapture') {
                    // If mouse is close and down, ascend
                    if (mouse.down && dist < 150) {
                        this.state = 'ascending';
                        this.ascendSpeed = 1;
                    } else if (dist < 300) {
                        // Walk towards light
                        this.x += dx * 0.01;
                    }
                } else if (mode === 'chaos') {
                    // Run away from light
                    if (dist < 200) {
                        this.x -= dx * 0.05;
                    } else {
                        // Random panic
                        this.x += (Math.random() - 0.5) * 5;
                    }
                } else {
                    // Calm - just stand and look
                }

                // Keep in bounds
                if (this.x < 0) this.x = 0;
                if (this.x > width) this.x = width;
            }

            draw() {
                if (this.opacity <= 0) return;

                ctx.globalAlpha = this.opacity;
                
                // Silhouette Color
                // Closer to front = darker, further = lighter (atmospheric perspective)
                const depthColor = Math.floor(20 + (1 - this.scale) * 50);
                ctx.fillStyle = `rgb(${depthColor}, ${depthColor + 5}, ${depthColor + 15})`;

                const h = 70 * this.scale;
                const w = 20 * this.scale;

                ctx.save();
                ctx.translate(this.x, this.y);

                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(0, 0, w, w/3, 0, 0, Math.PI*2);
                ctx.fill();

                // Body
                ctx.fillStyle = `rgb(${depthColor}, ${depthColor + 5}, ${depthColor + 15})`;
                ctx.beginPath();
                // Coat shape
                ctx.moveTo(-w/2, -h * 0.8);
                ctx.lineTo(w/2, -h * 0.8);
                ctx.lineTo(w * 0.8, 0); // feet
                ctx.lineTo(-w * 0.8, 0);
                ctx.fill();

                // Head
                ctx.beginPath();
                ctx.arc(0, -h * 0.9, w * 0.4, 0, Math.PI * 2);
                ctx.fill();

                // Highlight from the light (Rim lighting)
                if (mouse.y < this.y) {
                    ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, -h * 0.9, w * 0.4, -Math.PI/2, 0); // Top right rim
                    ctx.stroke();
                }

                ctx.restore();
                ctx.globalAlpha = 1;
            }
        }

        // Initialization
        function init() {
            for(let i=0; i<CROWD_SIZE; i++) {
                entities.push(new Person());
            }
            for(let i=0; i<5; i++) {
                drones.push(new Drone());
            }
            updateUI();
        }

        function updateUI() {
            document.getElementById('score').innerText = score;
            document.getElementById('population').innerText = CROWD_SIZE - score; // Just a visual trick, they respawn
        }

        function setMode(m) {
            mode = m;
            document.querySelectorAll('.controls button').forEach(b => b.classList.remove('active'));
            document.getElementById(`mode-${m}`).classList.add('active');
        }

        // Main Loop
        function animate() {
            ctx.clearRect(0, 0, width, height);
            frame++;

            // 1. Draw Light Source (The Singularity)
            // We draw this on canvas to get the interaction right
            const gradient = ctx.createRadialGradient(mouse.x, mouse.y, 10, mouse.x, mouse.y, 400);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.1, 'rgba(200, 240, 255, 0.8)');
            gradient.addColorStop(0.2, 'rgba(244, 114, 182, 0.4)'); // Pinkish
            gradient.addColorStop(0.4, 'rgba(56, 189, 248, 0.1)'); // Blueish
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);

            // Pulse Animation
            if (pulseRadius > 0) {
                ctx.beginPath();
                ctx.arc(mouse.x, mouse.y, pulseRadius, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(255, 255, 255, ${1 - pulseRadius/500})`;
                ctx.lineWidth = 5;
                ctx.stroke();
                pulseRadius += 15;
                if (pulseRadius > 500) pulseRadius = 0;
            }

            // Lens Flare Line
            ctx.beginPath();
            ctx.moveTo(0, mouse.y);
            ctx.lineTo(width, mouse.y);
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 1;
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(mouse.x, 0);
            ctx.lineTo(mouse.x, height);
            ctx.stroke();

            // 2. Draw Drones
            drones.forEach(d => {
                d.update();
                d.draw();
            });

            // 3. Sort Entities by Y for correct occlusion (painter's algorithm)
            entities.sort((a, b) => a.y - b.y);

            // 4. Update & Draw Entities
            entities.forEach(e => {
                e.update();
                e.draw();
            });

            // 5. Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                particles[i].draw();
                if (particles[i].life <= 0) particles.splice(i, 1);
            }

            // 6. Draw Beam if mouse down
            if (mouse.down && mode === 'rapture') {
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(mouse.x, mouse.y);
                ctx.lineTo(mouse.x - 50, height);
                ctx.lineTo(mouse.x + 50, height);
                ctx.closePath();
                const beamGrad = ctx.createLinearGradient(0, mouse.y, 0, height);
                beamGrad.addColorStop(0, 'rgba(255,255,255,0.5)');
                beamGrad.addColorStop(1, 'rgba(56, 189, 248, 0)');
                ctx.fillStyle = beamGrad;
                ctx.fill();
                ctx.restore();
            }

            requestAnimationFrame(animate);
        }

        init();
        animate();

    </script>
</body>
</html>